### 2019.4.15 完美世界算法工程师面试

只记得一些题目了… ...



#### 选择题

```c++
char a[10]
sizeof(a) ==  10
# int b , sizeof(b) == 4, int 4 个字节， float 4 个字节
```

```c++
# 返回值是
double * func()
```

```c++
# switch case 语句
switch 
```

```c++
# 虚基类
```

```c++
# 析构函数顺序

# 例子：http://www.runoob.com/cplusplus/cpp-constructor-destructor.html
#include <stdio.h>
#include <iostream>
using namespace std;
class Line{
public:
    void setLength(double len);
    double getLength();
    // 构造函数
    Line(double len);
    // 析构函数
    ~Line();
private:
    double length;
};

void Line::setLength(double len) {
    length = len;
}

double Line::getLength() {
    return length;
}

//Line::Line(double len) {
//    cout<< "Object is being created"<<endl;
//    length = len;
//}

// 或者使用初始化列表来初始化
// C::C(double a, double b, double c): X(a), Y(b), Z(c) {...}
Line::Line(double len): length(len) {
    cout<< "Object is being created" <<endl;
}

// 析构函数无返回值，无参数传递
Line::~Line() {
    cout<< "Object is being deleted" <<endl;
}

int main() {
    Line a(10.9);
    cout<< a.getLength() << endl;
    return 0;
}


# 2.0 继承之后的构造函数，和析构函数执行顺序
# 派生类继承所有的基类方法，除了：
# 											基类的构造函数，析构函数，拷贝构造函数
#												基类的重载运算符
#												基类的友元函数

# 继承方式：
# 最常用的是公有继承：原来是公有，继承后是公有
# 									    保护，继承后是保护
#                       私有，不能直接继承下来，但可以通过基类的公有，受保护的成员来访问
# 保护继承：				公有，保护成员，继承后为保护
# 私有继承：       公有，保护成员，集成后为私有
#
#include <iostream>

using namespace std;

class Shape{
public:
    void setWidth(int w) {
        width = w;
    }
    void setHight(int h) {
        height = h;
    }
    Shape(int w, int h):width(w), height(h) {
        cout<< "is creating Shape" <<endl;
    }
    ~Shape() {
        cout<< "is del Shape" << endl;
    }
protected:
    int width;
    int height;
};

// 派生类， 默认私有继承 private Shape
// 派生类要使用基类构造函数，必须在构造函数中显式声明
class Rectangle: public Shape {
public:
    Rectangle(int w, int h): Shape(w, h) {
        cout << "is creating Rectangle" << endl;
    }
    ~Rectangle() {
        cout << "is del Rectangle" << endl;
    }
    int getArea() {
         return (width*height);
    }
};

int main() {
    Rectangle a(5, 7);
    cout<< a.getArea() <<endl;
    return 0;
}
// 可以知道，创建顺序：Shape, Rectangle
//         销毁顺序：Rectangle, Shape
// 如果基类有多个构造函数，那么派生类也要全部继承下来，C++11使用using 解决
// http://www.runoob.com/w3cnote/cpp11-inheritance-constructor.html
```



```c++
# 先序遍历，中序遍历，后序遍历
# 结论：中序序列，先序序列 可以确定一棵树
#      中序序列，后序序列 可以确定一棵树
# 例子：先序遍历(前序遍历)(根左右)：GDAFEMHZ
#      中序遍历(左根右)：         ADEFGHMZ
```

![先序序列，中序序列确定](<https://github.com/Jian-Yin-Shine/Interview/blob/master/1.jpg>)

```c++
# 左值引用，右值引用
```

```c++
# 堆排序

```

```java
# java 的hashmap, hashtable区别
```





#### 编程题

```c++
# 买一个n元的物品，然后有k种劵，每种劵可以有无数张，面值给定，然后买这个n元的物品最少要几张劵
# 无穷背包

```



```
# 整数分解：输入n，求 n 有多少种分解方式
# 例如： 4：[1, 1, 1, 1], [1, 1, 2], [2, 2], [1, 3], [4]
				5: [1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 1, 3], [1, 2, 2], [2, 3], [1, 4], [5]
# tips: [2, 3] 和 [3, 2] 是一样的，不care顺序
```

